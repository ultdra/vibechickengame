{"version":3,"file":"Stage.mjs","sources":["../src/Stage.ts"],"sourcesContent":["import { Container, DisplayObject } from '@pixi/display';\nimport { Layer } from './Layer';\nimport { Group } from './Group';\n\n/**\n * The {@link Stage stage} manages all the layers in its scene tree.\n *\n * @memberof PIXI.layers\n */\nexport class Stage extends Layer\n{\n    static _updateOrderCounter = 0;\n\n    /** Flags that this is a {@link Stage stage}! */\n    public readonly isStage = true;\n\n    _tempGroups: Array<DisplayObject> = [];\n\n    /**\n     * Found layers\n     * @private\n     */\n    _activeLayers: Array<Layer> = [];\n\n    _activeParentStage: Stage = null;\n\n    /**\n     * clears all display lists that were used in last rendering session\n     * please clear it when you stop using this displayList, otherwise you may have problems with GC in some cases\n     */\n    clear(): void\n    {\n        this._activeLayers.length = 0;\n        this._tempGroups.length = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    destroy(options?: any): void\n    {\n        this.clear();\n        super.destroy(options);\n    }\n\n    /**\n     * This should be called before rendering for resolving items in the scene tree to their {@link Layer layers}.\n     *\n     * If your scene's root is a {@link Stage}, then the {@link ILayerRenderer} mixin will automatically\n     * call it.\n     */\n    updateStage(): void\n    {\n        this._activeParentStage = null;\n        Group._layerUpdateId++;\n        this._updateStageInner();\n    }\n\n    private updateAsChildStage(stage: Stage): void\n    {\n        this._activeParentStage = stage;\n        Stage._updateOrderCounter = 0;\n        this._updateStageInner();\n    }\n\n    private _updateStageInner(): void\n    {\n        this.clear();\n        this._addRecursive(this);\n        const layers = this._activeLayers;\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            const layer = layers[i];\n\n            if (layer.group.sortPriority)\n            {\n                layer._onEndLayerSubtreeTraversal();\n                const sorted = layer._sortedChildren;\n\n                for (let j = 0; j < sorted.length; j++)\n                {\n                    this._addRecursiveChildren(sorted[j]);\n                }\n            }\n        }\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            const layer = layers[i];\n\n            if (!layer.group.sortPriority)\n            {\n                layer._onEndLayerSubtreeTraversal();\n            }\n        }\n    }\n\n    private _addRecursive(displayObject: DisplayObject): void\n    {\n        if (!displayObject.visible)\n        {\n            return;\n        }\n\n        if ((displayObject as any).isLayer)\n        {\n            const layer = displayObject as any as Layer;\n\n            this._activeLayers.push(layer);\n            layer._onBeginLayerSubtreeTraversal(this);\n        }\n\n        if (displayObject !== this && (displayObject as any).isStage)\n        {\n            const stage = displayObject as Stage;\n\n            stage.updateAsChildStage(this);\n\n            return;\n        }\n\n        displayObject._activeParentLayer = null;\n        let group = displayObject.parentGroup;\n\n        if (group)\n        {\n            group._resolveChildDisplayObject(this, displayObject);\n        }\n        const layer = displayObject.parentLayer;\n\n        if (layer)\n        {\n            group = layer.group;\n            group._resolveChildDisplayObject(this, displayObject);\n        }\n\n        displayObject.updateOrder = ++Stage._updateOrderCounter;\n        if (displayObject.alpha <= 0 || !displayObject.renderable\n            || !displayObject.layerableChildren\n            || (group && group.sortPriority))\n        {\n            return;\n        }\n\n        const children = (displayObject as Container).children;\n\n        if (children && children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._addRecursive(children[i]);\n            }\n        }\n    }\n\n    private _addRecursiveChildren(displayObject: DisplayObject): void\n    {\n        if (displayObject.alpha <= 0 || !displayObject.renderable\n            || !displayObject.layerableChildren)\n        {\n            return;\n        }\n        const children = (displayObject as Container).children;\n\n        if (children && children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._addRecursive(children[i]);\n            }\n        }\n    }\n}\n"],"names":["layer"],"mappings":"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"}